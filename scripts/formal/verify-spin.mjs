#!/usr/bin/env node
// Lightweight SPIN runner (Promela): generates pan, compiles, runs, and writes a summary JSON. Non-blocking.
import { spawnSync } from 'node:child_process';
import fs from 'node:fs';
import os from 'node:os';
import path from 'node:path';

function parseArgs(argv) {
  const args = { _: [] };
  for (let i = 2; i < argv.length; i += 1) {
    const a = argv[i];
    const next = argv[i + 1];
    if (a === '--help' || a === '-h') args.help = true;
    else if (a === '--file' && next) { args.file = next; i += 1; }
    else if (a.startsWith('--file=')) { args.file = a.slice(7); }
    else if (a === '--ltl' && next) { args.ltl = next; i += 1; }
    else if (a.startsWith('--ltl=')) { args.ltl = a.slice(6); }
    else if (a === '--timeout' && next) { args.timeout = next; i += 1; }
    else if (a.startsWith('--timeout=')) { args.timeout = a.slice(10); }
    else if (a === '--max-depth' && next) { args.maxDepth = next; i += 1; }
    else if (a.startsWith('--max-depth=')) { args.maxDepth = a.slice(12); }
    else { args._.push(a); }
  }
  return args;
}

function commandExists(cmd) {
  const result = spawnSync(cmd, [], { stdio: 'ignore' });
  if (result.error && result.error.code === 'ENOENT') return false;
  return true;
}

function runCommand(cmd, cmdArgs, options = {}) {
  const result = spawnSync(cmd, cmdArgs, { encoding: 'utf8', cwd: options.cwd });
  const stdout = result.stdout ?? '';
  const stderr = result.stderr ?? '';
  const output = `${stdout}${stderr}`;
  if (result.error) {
    return { available: false, status: result.status ?? null, output: output || (result.error.message ?? ''), errorCode: result.error.code ?? null };
  }
  return { available: true, status: result.status ?? null, output, errorCode: null };
}

function clamp(s, n = 4000) {
  const t = String(s || '');
  return t.length > n ? `${t.slice(0, n)}â€¦` : t;
}

const args = parseArgs(process.argv);
if (args.help) {
  console.log('Usage: node scripts/formal/verify-spin.mjs [--file spec/spin/sample.pml] [--ltl p_done] [--timeout <ms>] [--max-depth <n>]');
  process.exit(0);
}

const repoRoot = process.cwd();
const file = args.file || path.join('spec', 'spin', 'sample.pml');
const absFile = path.resolve(repoRoot, file);
const ltl = args.ltl || '';
const timeoutMs = Number.isFinite(Number(args.timeout)) ? Number(args.timeout) : 0;
const timeoutSec = timeoutMs > 0 ? Math.max(1, Math.floor(timeoutMs / 1000)) : 0;
const maxDepth = Number.isFinite(Number(args.maxDepth)) ? Math.max(1, Math.floor(Number(args.maxDepth))) : 10000;

const outDir = path.join(repoRoot, 'artifacts', 'hermetic-reports', 'formal');
const outFile = path.join(outDir, 'spin-summary.json');
const outLog = path.join(outDir, 'spin-output.txt');
fs.mkdirSync(outDir, { recursive: true });

let ran = false;
let status = 'n/a';
let output = '';
let tool = 'spin';
let exitCode = null;
let ok = null;
let timeMs = null;

if (!fs.existsSync(absFile)) {
  status = 'file_not_found';
  output = `Promela file not found: ${absFile}`;
} else if (!commandExists('spin')) {
  status = 'tool_not_available';
  output = "SPIN not found. Install 'spin' (and gcc) to run Promela checks.";
} else if (!commandExists('gcc')) {
  status = 'compile_not_available';
  output = "gcc not found. Install 'gcc' to compile pan.c generated by SPIN.";
} else {
  const t0 = Date.now();
  const tmp = fs.mkdtempSync(path.join(os.tmpdir(), 'spin-'));
  try {
    const modelName = path.basename(absFile);
    const tmpModel = path.join(tmp, modelName);
    fs.copyFileSync(absFile, tmpModel);

    const genArgs = ['-a'];
    if (ltl) genArgs.push('-N', ltl);
    genArgs.push(tmpModel);
    const gen = runCommand('spin', genArgs, { cwd: tmp });
    if (!gen.available || gen.status !== 0) {
      status = 'gen_failed';
      output = clamp(gen.output || 'spin -a failed');
    } else if (!fs.existsSync(path.join(tmp, 'pan.c'))) {
      status = 'gen_failed';
      output = 'spin -a succeeded but pan.c was not generated';
    } else {
      const cc = runCommand('gcc', ['-O2', '-o', 'pan', 'pan.c'], { cwd: tmp });
      if (!cc.available || cc.status !== 0) {
        status = 'compile_failed';
        output = clamp([gen.output, cc.output].filter(Boolean).join('\n'));
      } else {
        const haveTimeout = commandExists('timeout');
        const panArgs = ['-a', `-m${maxDepth}`];
        const runSpec = (timeoutSec > 0 && haveTimeout)
          ? { cmd: 'timeout', args: [`${timeoutSec}s`, './pan', ...panArgs] }
          : { cmd: './pan', args: panArgs };
        const pan = runCommand(runSpec.cmd, runSpec.args, { cwd: tmp });
        ran = pan.available;
        exitCode = pan.status;
        if (!pan.available) {
          status = 'tool_not_available';
          output = clamp(pan.output || 'Failed to execute pan');
        } else {
          status = (timeoutSec > 0 && haveTimeout && pan.status === 124) ? 'timeout' : (pan.status === 0 ? 'ran' : 'failed');
          output = clamp([gen.output, cc.output, pan.output].filter(Boolean).join('\n'));
        }
      }
    }
  } finally {
    try { fs.rmSync(tmp, { recursive: true, force: true }); } catch {}
  }
  timeMs = Date.now() - t0;
}

if (ran) {
  ok = status === 'ran' ? true : (status === 'failed' ? false : null);
}

try { fs.writeFileSync(outLog, output, 'utf-8'); } catch {}

const summary = {
  tool,
  file: path.relative(repoRoot, absFile),
  ltl: ltl || null,
  ran,
  status,
  ok,
  exitCode,
  timeMs,
  timestamp: new Date().toISOString(),
  output,
  outputFile: path.relative(repoRoot, outLog),
};
fs.writeFileSync(outFile, JSON.stringify(summary, null, 2));
console.log(`SPIN summary written: ${path.relative(repoRoot, outFile)}`);
console.log(`- file=${summary.file} status=${status}${ltl ? ` ltl=${ltl}` : ''}`);

// Non-blocking
process.exit(0);
