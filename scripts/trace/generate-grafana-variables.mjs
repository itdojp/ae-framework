#!/usr/bin/env node
import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';
import { buildTempoLinks } from './tempo-link-utils.mjs';

function parseArgs(argv) {
  const options = {
    envelope: process.env.GRAFANA_VARIABLE_ENVELOPE ?? 'artifacts/trace/report-envelope.json',
    summary: process.env.GRAFANA_VARIABLE_TRACE_SUMMARY ?? 'artifacts/kvonce-trace-summary.json',
    stepSummary: process.env.GRAFANA_VARIABLE_STEP_SUMMARY ?? null,
    output: process.env.GRAFANA_VARIABLE_OUTPUT ?? 'artifacts/trace/grafana-variables.json',
  };

  for (let i = 2; i < argv.length; i += 1) {
    const arg = argv[i];
    const next = argv[i + 1];
    if ((arg === '--envelope' || arg === '-e') && next) {
      options.envelope = next;
      i += 1;
    } else if ((arg === '--trace-summary' || arg === '-t') && next) {
      options.summary = next;
      i += 1;
    } else if ((arg === '--step-summary' || arg === '-s') && next) {
      options.stepSummary = next;
      i += 1;
    } else if ((arg === '--output' || arg === '-o') && next) {
      options.output = next;
      i += 1;
    } else if (arg === '--help' || arg === '-h') {
      console.log(`Usage: node scripts/trace/generate-grafana-variables.mjs [options]

Options:
  -e, --envelope <file>        Report envelope JSON (default: artifacts/trace/report-envelope.json)
  -t, --trace-summary <file>   KvOnce trace summary JSON (default: artifacts/kvonce-trace-summary.json)
  -s, --step-summary <file>    Step summary Markdown generated by verify:conformance
  -o, --output <file>          Output JSON for Grafana variables (default: artifacts/trace/grafana-variables.json)
  -h, --help                   Show this message
`);
      process.exit(0);
    }
  }

  return options;
}

function isErrnoException(error) {
  return error instanceof Error && 'code' in error;
}

function readFileIfExists(resolvedPath) {
  if (!resolvedPath) return null;
  try {
    return fs.readFileSync(resolvedPath, 'utf8');
  } catch (error) {
    if (isErrnoException(error) && error.code === 'ENOENT') {
      return null;
    }
    console.error(`[grafana-variables] failed to read file: ${resolvedPath}`);
    console.error(error.message);
    process.exit(1);
  }
}

function readJsonSafe(resolvedPath) {
  const content = readFileIfExists(resolvedPath);
  if (content == null) return { value: null, found: false };
  try {
    return { value: JSON.parse(content), found: true };
  } catch (error) {
    console.error(`[grafana-variables] failed to parse JSON: ${resolvedPath}`);
    console.error(error.message);
    process.exit(1);
  }
}

function readTextSafe(resolvedPath) {
  const content = readFileIfExists(resolvedPath);
  if (content == null) return { value: null, found: false };
  return { value: content, found: true };
}

function coerceArray(value) {
  if (!Array.isArray(value)) return [];
  return value
    .map((item) => (typeof item === 'string' ? item.trim() : ''))
    .filter(Boolean);
}

function extractTempoLinksFromStepSummary(markdown) {
  if (!markdown) return [];
  const links = new Set();
  const linkRegex = /Tempo:\s+(https?:\/\/\S+)/gi;
  let match;
  while ((match = linkRegex.exec(markdown)) !== null) {
    links.add(match[1]);
  }

  const listRegex = /^\s*-\s+(https?:\/\/\S+)/gim;
  while ((match = listRegex.exec(markdown)) !== null) {
    const value = match[1];
    if (value.includes('tempo') || value.includes('explore')) {
      links.add(value);
    }
  }
  return Array.from(links);
}

function extractTraceIdsFromStepSummary(markdown) {
  if (!markdown) return [];
  const ids = new Set();
  const lineRegex = /^\s*[-*]\s*trace ids?\s*:\s*(.+)$/gim;
  let match;
  while ((match = lineRegex.exec(markdown)) !== null) {
    for (const chunk of match[1].split(',')) {
      const value = chunk.trim();
      if (value) ids.add(value);
    }
  }
  const tempoLinks = extractTempoLinksFromStepSummary(markdown);
  const traceIdParam = /[?&]traceId=([^&]+)/i;
  for (const link of tempoLinks) {
    const tempoMatch = traceIdParam.exec(link);
    if (tempoMatch && tempoMatch[1]) {
      const decoded = decodeURIComponent(tempoMatch[1]);
      if (decoded) ids.add(decoded);
    }
  }
  return Array.from(ids);
}

function buildVariableEntries(values, { labelPrefix = '', includeText = false } = {}) {
  return values.map((value) => {
    const entry = { value };
    if (includeText || labelPrefix) {
      entry.text = labelPrefix ? `${labelPrefix}${value}` : value;
    }
    return entry;
  });
}

function collectCaseVariables(traceSummary) {
  if (!traceSummary || !Array.isArray(traceSummary.cases)) return [];
  return traceSummary.cases.map((item) => {
    const traceIds = coerceArray(item.traceIds);
    const tempoLinks = coerceArray(item.tempoLinks);
    return {
      format: item.format ?? item.key ?? 'unknown',
      label: item.label ?? item.key ?? 'unknown',
      traceIds,
      tempoLinks,
      valid: item.valid ?? null,
    };
  });
}

function main() {
  const options = parseArgs(process.argv);
  const resolvedOutput = path.resolve(options.output);
  fs.mkdirSync(path.dirname(resolvedOutput), { recursive: true });

  const envelopePath = options.envelope ? path.resolve(options.envelope) : null;
  const traceSummaryPath = options.summary ? path.resolve(options.summary) : null;
  const stepSummaryPath = options.stepSummary ? path.resolve(options.stepSummary) : null;

  const envelopeResult = readJsonSafe(envelopePath);
  const traceSummaryResult = readJsonSafe(traceSummaryPath);
  const stepSummaryResult = readTextSafe(stepSummaryPath);

  const envelope = envelopeResult.value;
  const traceSummary = traceSummaryResult.value;
  const stepSummaryMarkdown = stepSummaryResult.value;

  const traceIds = new Set();
  const tempoLinks = new Set();

  const tempoTemplate = process.env.REPORT_ENVELOPE_TEMPO_LINK_TEMPLATE ?? null;

  if (envelope) {
    const fromSummary = coerceArray(envelope?.summary?.trace?.traceIds);
    fromSummary.forEach((value) => traceIds.add(value));
    const envelopeTempoLinks = coerceArray(envelope?.tempoLinks ?? envelope?.summary?.tempoLinks);
    envelopeTempoLinks.forEach((value) => tempoLinks.add(value));
  }

  if (traceSummary) {
    coerceArray(traceSummary.traceIds).forEach((value) => traceIds.add(value));
    coerceArray(traceSummary.tempoLinks).forEach((value) => tempoLinks.add(value));
    for (const item of traceSummary.cases ?? []) {
      coerceArray(item.traceIds).forEach((value) => traceIds.add(value));
      coerceArray(item.tempoLinks).forEach((value) => tempoLinks.add(value));
    }
  }

  if (stepSummaryMarkdown) {
    extractTempoLinksFromStepSummary(stepSummaryMarkdown).forEach((value) => tempoLinks.add(value));
    extractTraceIdsFromStepSummary(stepSummaryMarkdown).forEach((value) => traceIds.add(value));
  }

  if (traceIds.size > 0 && tempoLinks.size === 0 && tempoTemplate) {
    buildTempoLinks(Array.from(traceIds), tempoTemplate).forEach((value) => tempoLinks.add(value));
  }

  const cases = collectCaseVariables(traceSummary);
  const metadata = {};
  if (envelope?.correlation) {
    const { runId, workflow, branch, commit } = envelope.correlation;
    if (runId) metadata.runId = runId;
    if (workflow) metadata.workflow = workflow;
    if (branch) metadata.branch = branch;
    if (commit) metadata.commit = commit;
  }
  if (envelope?.source) {
    metadata.source = envelope.source;
  }

  const traceIdsList = Array.from(traceIds);
  traceIdsList.sort();
  const tempoLinksList = Array.from(tempoLinks);
  tempoLinksList.sort();

  const output = {
    schemaVersion: '2025-10-variables',
    generatedAt: new Date().toISOString(),
    sources: {
      envelope: envelopeResult.found ? path.relative(process.cwd(), envelopePath) : null,
      traceSummary: traceSummaryResult.found ? path.relative(process.cwd(), traceSummaryPath) : null,
      stepSummary: stepSummaryResult.found ? path.relative(process.cwd(), stepSummaryPath) : null,
    },
    metadata,
    trace: {
      traceIds: traceIdsList,
      tempoLinks: tempoLinksList,
      tempoLinkTemplate: tempoTemplate,
    },
    cases,
    variables: {
      traceIds: buildVariableEntries(traceIdsList),
      tempoLinks: buildVariableEntries(tempoLinksList),
      cases: cases.map((item) => ({
        value: item.format,
        text: item.label ?? item.format,
      })),
    },
  };

  fs.writeFileSync(resolvedOutput, JSON.stringify(output, null, 2));
  console.log(`[grafana-variables] wrote ${resolvedOutput}`);
}

const isDirectExecution = (() => {
  const scriptPath = process.argv[1] ? path.resolve(process.argv[1]) : null;
  if (!scriptPath) return false;
  return fileURLToPath(import.meta.url) === scriptPath;
})();

if (isDirectExecution) {
  main();
}
