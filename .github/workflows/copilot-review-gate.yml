name: Copilot Review Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  pull_request_review:
    types: [submitted]
  issue_comment:
    types: [created, edited]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to check (optional; required for manual runs on main)"
        required: false
        type: number

concurrency:
  group: >-
    copilot-review-gate-${{ github.event_name == 'issue_comment' && 'issue' || 'pr' }}-${{
      github.event.pull_request.number || github.event.issue.number || github.event.inputs.pr_number || github.ref
    }}
  cancel-in-progress: true

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  dispatch:
    if: >-
      github.event_name == 'issue_comment'
      && github.event.issue.pull_request
      && contains(github.event.comment.body, '<!-- AE-COPILOT-AUTO-FIX v1 -->')
      && github.event.comment.user.type == 'Bot'
      && github.event.comment.user.login == 'github-actions[bot]'
    runs-on: ubuntu-latest
    permissions:
      actions: write
      contents: read
      pull-requests: read
    steps:
      - name: Dispatch gate run on PR head
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.issue?.number;
            if (!prNumber) {
              core.setFailed('Missing PR number in issue_comment payload');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: 'copilot-review-gate.yml',
              ref: pr.head.ref,
              inputs: { pr_number: String(prNumber) }
            });

            core.notice(`Dispatched gate for PR #${prNumber} at ${pr.head.ref}`);

  gate:
    if: github.event_name != 'issue_comment'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Setup Node + pnpm
        uses: ./.github/actions/setup-node-pnpm
        with:
          node-version: "20"
      - name: Resolve automation config
        env:
          AE_AUTOMATION_PROFILE: ${{ vars.AE_AUTOMATION_PROFILE || '' }}
          AE_COPILOT_AUTO_FIX: ${{ vars.AE_COPILOT_AUTO_FIX || '' }}
          AE_COPILOT_AUTO_FIX_SCOPE: ${{ vars.AE_COPILOT_AUTO_FIX_SCOPE || '' }}
          AE_COPILOT_AUTO_FIX_LABEL: ${{ vars.AE_COPILOT_AUTO_FIX_LABEL || '' }}
          AE_AUTO_MERGE: ${{ vars.AE_AUTO_MERGE || '' }}
          AE_AUTO_MERGE_MODE: ${{ vars.AE_AUTO_MERGE_MODE || '' }}
          AE_AUTO_MERGE_LABEL: ${{ vars.AE_AUTO_MERGE_LABEL || '' }}
          AE_GH_THROTTLE_MS: ${{ vars.AE_GH_THROTTLE_MS || '' }}
          AE_GH_RETRY_MAX_ATTEMPTS: ${{ vars.AE_GH_RETRY_MAX_ATTEMPTS || '' }}
          AE_GH_RETRY_INITIAL_DELAY_MS: ${{ vars.AE_GH_RETRY_INITIAL_DELAY_MS || '' }}
          AE_GH_RETRY_MAX_DELAY_MS: ${{ vars.AE_GH_RETRY_MAX_DELAY_MS || '' }}
          AE_GH_RETRY_DEBUG: ${{ vars.AE_GH_RETRY_DEBUG || '' }}
          COPILOT_REVIEW_WAIT_MINUTES: ${{ vars.COPILOT_REVIEW_WAIT_MINUTES || '' }}
          COPILOT_REVIEW_MAX_ATTEMPTS: ${{ vars.COPILOT_REVIEW_MAX_ATTEMPTS || '' }}
        run: |
          node scripts/ci/lib/automation-config.mjs --format github-env >> "$GITHUB_ENV"
          node scripts/ci/lib/automation-config.mjs --format summary >> "$GITHUB_STEP_SUMMARY"
      - name: Check Copilot review presence and resolution
        uses: actions/github-script@v7
        env:
          COPILOT_ACTORS: copilot-pull-request-reviewer,github-copilot,github-copilot[bot],copilot,copilot[bot]
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const inputNumber = core.getInput('pr_number') || context.payload.inputs?.pr_number;
            const parsedInput = inputNumber ? Number(inputNumber) : null;
            const number = context.payload.pull_request?.number ?? context.payload.issue?.number ?? parsedInput;
            const isValidNumber = typeof number === 'number' && Number.isFinite(number) && number > 0;
            if (!isValidNumber) {
              const defaultBranch = context.payload.repository?.default_branch;
              const isDefaultBranch =
                defaultBranch && context.ref === `refs/heads/${defaultBranch}`;
              if (context.eventName === 'workflow_dispatch' && isDefaultBranch) {
                core.notice('No PR context or valid pr_number provided; skipping gate on default branch.');
                return;
              }
              core.setFailed('No PR context or valid pr_number provided; manual runs on non-default branches must supply pr_number.');
              return;
            }
            if (context.eventName === 'issue_comment' && !context.payload.issue?.pull_request) {
              core.notice('Issue comment is not for a pull request; skipping.');
              return;
            }
            const actors = (process.env.COPILOT_ACTORS || 'github-copilot,github-copilot[bot]')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);
            const waitMinutesRaw = Number(process.env.COPILOT_REVIEW_WAIT_MINUTES || '5');
            const maxAttemptsRaw = Number(process.env.COPILOT_REVIEW_MAX_ATTEMPTS || '3');
            const waitMinutes = Number.isFinite(waitMinutesRaw) && waitMinutesRaw >= 0 ? waitMinutesRaw : 5;
            const maxAttempts = Number.isFinite(maxAttemptsRaw) && maxAttemptsRaw > 0 ? maxAttemptsRaw : 3;
            const waitMs = waitMinutes * 60 * 1000;
            const allowComment =
              context.eventName === 'issue_comment' ? true : context.payload.pull_request?.head?.repo?.fork !== true;

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const marker = '<!-- copilot-review-gate -->';
            const upsertComment = async (body) => {
              const decoratedBody = `${body}\n\n${marker}`;
              const { data: existing } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number
              });
              const previous = existing.find((c) => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));
              if (previous) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: previous.id,
                  body: decoratedBody
                });
                return;
              }
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: decoratedBody
              });
            };
            const safeUpsertComment = async (body, contextLabel) => {
              if (!allowComment) {
                core.notice(`Skipping PR comment (${contextLabel}): forked PR has no comment permission.`);
                return;
              }
              try {
                await upsertComment(body);
              } catch (error) {
                const message = error && error.message ? error.message : String(error);
                core.warning(`Failed to post PR comment (${contextLabel}): ${message}`);
              }
            };

            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviews(last: 50) {
                    nodes { author { login } state }
                  }
                  reviewThreads(first: 100) {
                    nodes {
                      isResolved
                      comments(first: 25) { nodes { author { login } bodyText } }
                    }
                  }
                }
              }
            }`;

            let pr = null;
            let hasCopilotReview = false;
            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              const data = await github.graphql(query, { owner, repo, number });
              pr = data.repository.pullRequest;
              if (!pr) {
                core.setFailed('Cannot load PR via GraphQL');
                return;
              }
              const reviewAuthors = pr.reviews.nodes.map(r => r.author && r.author.login).filter(Boolean);
              hasCopilotReview = reviewAuthors.some(login => actors.includes(login));
              if (hasCopilotReview) {
                break;
              }
              if (attempt < maxAttempts) {
                const attemptLabel = `attempt ${attempt + 1} of ${maxAttempts}`;
                if (waitMinutes > 0) {
                  core.notice(`No Copilot review found. Retrying in ${waitMinutes} minute${waitMinutes === 1 ? '' : 's'} (${attemptLabel}).`);
                  await sleep(waitMs);
                } else {
                  core.notice(`No Copilot review found. Retrying shortly (${attemptLabel}).`);
                }
              }
            }
            if (!hasCopilotReview) {
              const body = [
                '### Copilot Review Gate',
                `No Copilot review found after ${maxAttempts} attempt${maxAttempts === 1 ? '' : 's'} with ${waitMinutes} minute${waitMinutes === 1 ? '' : 's'} wait.`,
                `Expected reviewers: ${actors.join(', ')}`,
                'Action: request Copilot review and re-run the gate.'
              ].join('\n');
              await safeUpsertComment(body, 'missing-review');
              core.setFailed(`No Copilot review found (expected reviewers: ${actors.join(', ')})`);
              return;
            }

            const truncateUnicodeSafe = (text, maxChars) => {
              const normalized = (text || '').replace(/\s+/g, ' ').trim();
              const chars = Array.from(normalized);
              if (maxChars <= 0) {
                return '';
              }
              if (chars.length <= maxChars) {
                return normalized;
              }
              if (maxChars <= 3) {
                return chars.slice(0, maxChars).join('');
              }
              return `${chars.slice(0, maxChars - 3).join('')}...`;
            };

            const copilotThreads = pr.reviewThreads.nodes.filter(t =>
              t.comments.nodes.some(c => c.author && actors.includes(c.author.login))
            );
            const unresolved = copilotThreads.filter(t => !t.isResolved);
            if (unresolved.length > 0) {
              const unresolvedLines = unresolved.slice(0, 5).map((thread, index) => {
                const firstComment = thread.comments.nodes.find(c => c.author && actors.includes(c.author.login)) || thread.comments.nodes[0];
                const snippet = truncateUnicodeSafe(firstComment?.bodyText || '', 140);
                return `- Thread ${index + 1}: ${snippet || '(no comment body)'}`;
              });
              const body = [
                '### Copilot Review Gate',
                `Unresolved Copilot review threads: ${unresolved.length}.`,
                '',
                'Sample unresolved threads:',
                ...unresolvedLines,
                '',
                'Action: resolve the Copilot review threads and re-run the gate.'
              ].join('\n');
              await safeUpsertComment(body, 'unresolved-threads');
              core.setFailed(`Unresolved Copilot review threads: ${unresolved.length}. Resolve conversations before merge.`);
              return;
            }

            core.notice(`Copilot review present. Resolved threads: ${copilotThreads.length}.`);
