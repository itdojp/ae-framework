name: Copilot Review Gate

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "PR number to check (optional; required for manual runs on main)"
        required: false
        type: number

permissions:
  contents: read
  pull-requests: read
  issues: write

jobs:
  gate:
    runs-on: ubuntu-latest
    steps:
      - name: Check Copilot review presence and resolution
        uses: actions/github-script@v7
        env:
          COPILOT_ACTORS: copilot-pull-request-reviewer,github-copilot,github-copilot[bot],copilot,copilot[bot]
          COPILOT_REVIEW_WAIT_MINUTES: '5'
          COPILOT_REVIEW_MAX_ATTEMPTS: '3'
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const inputNumber = core.getInput('pr_number');
            const parsedInput = inputNumber ? Number(inputNumber) : null;
            const number = context.payload.pull_request?.number ?? parsedInput;
            const isValidNumber = typeof number === 'number' && Number.isFinite(number) && number > 0;
            if (!isValidNumber) {
              const defaultBranch = context.payload.repository?.default_branch;
              const isDefaultBranch =
                defaultBranch && context.ref === `refs/heads/${defaultBranch}`;
              if (context.eventName === 'workflow_dispatch' && isDefaultBranch) {
                core.notice('No PR context or valid pr_number provided; skipping gate on default branch.');
                return;
              }
              core.setFailed('No PR context or valid pr_number provided; manual runs on non-default branches must supply pr_number.');
              return;
            }
            const actors = (process.env.COPILOT_ACTORS || 'github-copilot,github-copilot[bot]')
              .split(',')
              .map(s => s.trim())
              .filter(Boolean);
            const waitMinutesRaw = Number(process.env.COPILOT_REVIEW_WAIT_MINUTES || '5');
            const maxAttemptsRaw = Number(process.env.COPILOT_REVIEW_MAX_ATTEMPTS || '3');
            const waitMinutes = Number.isFinite(waitMinutesRaw) && waitMinutesRaw >= 0 ? waitMinutesRaw : 5;
            const maxAttempts = Number.isFinite(maxAttemptsRaw) && maxAttemptsRaw > 0 ? maxAttemptsRaw : 3;
            const waitMs = waitMinutes * 60 * 1000;

            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const marker = '<!-- copilot-review-gate -->';
            const upsertComment = async (body) => {
              const decoratedBody = `${body}\n\n${marker}`;
              const { data: existing } = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: number
              });
              const previous = existing.find((c) => c.user?.login === 'github-actions[bot]' && c.body?.includes(marker));
              if (previous) {
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: previous.id,
                  body: decoratedBody
                });
                return;
              }
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: number,
                body: decoratedBody
              });
            };

            const query = `query($owner:String!, $repo:String!, $number:Int!) {
              repository(owner:$owner, name:$repo) {
                pullRequest(number:$number) {
                  reviews(last: 50) {
                    nodes { author { login } state }
                  }
                  reviewThreads(first: 100) {
                    nodes {
                      isResolved
                      comments(first: 25) { nodes { author { login } bodyText } }
                    }
                  }
                }
              }
            }`;

            let pr = null;
            let hasCopilotReview = false;
            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
              const data = await github.graphql(query, { owner, repo, number });
              pr = data.repository.pullRequest;
              if (!pr) {
                core.setFailed('Cannot load PR via GraphQL');
                return;
              }
              const reviewAuthors = pr.reviews.nodes.map(r => r.author && r.author.login).filter(Boolean);
              hasCopilotReview = reviewAuthors.some(login => actors.includes(login));
              if (hasCopilotReview) {
                break;
              }
              if (attempt < maxAttempts) {
                const attemptLabel = `attempt ${attempt + 1} of ${maxAttempts}`;
                if (waitMinutes > 0) {
                  core.notice(`No Copilot review found. Retrying in ${waitMinutes} minute${waitMinutes === 1 ? '' : 's'} (${attemptLabel}).`);
                  await sleep(waitMs);
                } else {
                  core.notice(`No Copilot review found. Retrying shortly (${attemptLabel}).`);
                }
              }
            }
            if (!hasCopilotReview) {
              const body = [
                '### Copilot Review Gate',
                `No Copilot review found after ${maxAttempts} attempt${maxAttempts === 1 ? '' : 's'} with ${waitMinutes} minute${waitMinutes === 1 ? '' : 's'} wait.`,
                `Expected reviewers: ${actors.join(', ')}`,
                'Action: request Copilot review and re-run the gate.'
              ].join('\n');
              await upsertComment(body);
              core.setFailed(`No Copilot review found (expected reviewers: ${actors.join(', ')})`);
              return;
            }

            const truncateUnicodeSafe = (text, maxChars) => {
              const normalized = (text || '').replace(/\s+/g, ' ').trim();
              const chars = Array.from(normalized);
              if (maxChars <= 0) {
                return '';
              }
              if (chars.length <= maxChars) {
                return normalized;
              }
              if (maxChars <= 3) {
                return chars.slice(0, maxChars).join('');
              }
              return `${chars.slice(0, maxChars - 3).join('')}...`;
            };

            const copilotThreads = pr.reviewThreads.nodes.filter(t =>
              t.comments.nodes.some(c => c.author && actors.includes(c.author.login))
            );
            const unresolved = copilotThreads.filter(t => !t.isResolved);
            if (unresolved.length > 0) {
              const unresolvedLines = unresolved.slice(0, 5).map((thread, index) => {
                const firstComment = thread.comments.nodes.find(c => c.author && actors.includes(c.author.login)) || thread.comments.nodes[0];
                const snippet = truncateUnicodeSafe(firstComment?.bodyText || '', 140);
                return `- Thread ${index + 1}: ${snippet || '(no comment body)'}`;
              });
              const body = [
                '### Copilot Review Gate',
                `Unresolved Copilot review threads: ${unresolved.length}.`,
                '',
                'Sample unresolved threads:',
                ...unresolvedLines,
                '',
                'Action: resolve the Copilot review threads and re-run the gate.'
              ].join('\n');
              await upsertComment(body);
              core.setFailed(`Unresolved Copilot review threads: ${unresolved.length}. Resolve conversations before merge.`);
              return;
            }

            core.notice(`Copilot review present. Resolved threads: ${copilotThreads.length}.`);
