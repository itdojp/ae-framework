name: Formal Reports Aggregate

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions: read-all

jobs:
  aggregate:
    if: contains(github.event.pull_request.labels.*.name, 'run-formal')
    runs-on: ubuntu-latest
    continue-on-error: true
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts_dl
      - name: Aggregate formal reports
        id: agg
        run: |
          node <<'JS'
          const fs=require("fs"), path=require("path");
          function rj(p){ try { return JSON.parse(fs.readFileSync(p,"utf-8")); } catch { return undefined; } }
          function find(dir, name){ try { const p = path.join(dir, name); return fs.existsSync(p) ? p : undefined; } catch { return undefined; } }
          const LINE_CLAMP = parseInt(process.env.FORMAL_AGG_LINE_CLAMP || '200', 10);
          const ERRORS_LIMIT = parseInt(process.env.FORMAL_AGG_ERRORS_LIMIT || '5', 10);
          function escMd(s){
            if (!s) return '';
            // Basic Markdown escaping to avoid breaking PR rendering
            return String(s)
              .replace(/`/g, "`\u200b")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
          }
          function clamp(s, n=LINE_CLAMP){ s = String(s||''); return s.length>n ? (s.slice(0,n)+"â€¦") : s; }
          const base = "artifacts_dl";
          const outDir = "artifacts/formal"; fs.mkdirSync(outDir,{recursive:true});
          const outMd = path.join(outDir, "formal-aggregate.md");
          const outJson = path.join(outDir, "formal-aggregate.json");

          const modelJson = find(base, "model-check-results/model-check.json");
          const alloy = modelJson ? (rj(modelJson)?.alloy || {}) : {};
          const tlc = modelJson ? (rj(modelJson)?.tlc || {}) : {};
          const alloyOk = Array.isArray(alloy.results) ? alloy.results.filter(x=>x?.ok===true).length : 0;
          const alloyTotal = Array.isArray(alloy.results) ? alloy.results.filter(x=>x?.ok!==undefined).length : 0;
          const tlcOk = Array.isArray(tlc.results) ? tlc.results.filter(x=>x?.ok===true).length : 0;
          const tlcTotal = Array.isArray(tlc.results) ? tlc.results.length : 0;

          const tlaSum = find(base, "formal-reports-tla/tla-summary.json");
          const alloySum = find(base, "formal-reports-alloy/alloy-summary.json");
          const smtSum = find(base, "formal-reports-smt/smt-summary.json");
          const apalacheSum = find(base, "formal-reports-apalache/apalache-summary.json");
          const apalacheOut = find(base, "formal-reports-apalache/apalache-output.txt");
          const confSum = find(base, "formal-reports-conformance/conformance-summary.json");

          const apalache = apalacheSum ? rj(apalacheSum) : undefined;
          const tla = tlaSum ? rj(tlaSum) : undefined;
          const smt = smtSum ? rj(smtSum) : undefined;
          const alloyS = alloySum ? rj(alloySum) : undefined;
          const conf = confSum ? rj(confSum) : undefined;
          const clampInfo = {
            lineClamp: process.env.FORMAL_AGG_LINE_CLAMP || '200',
            errorsLimit: process.env.FORMAL_AGG_ERRORS_LIMIT || '5'
          };

          const lines = [];
          lines.push("## ðŸ”Ž Formal Reports Aggregate");
          lines.push("");
          lines.push(`- TLC: ${tlcOk}/${tlcTotal} ok`);
          lines.push(`- Alloy: ${alloyOk}/${alloyTotal} ok`);
          lines.push(tlaSum ? `- TLA summary file: ${path.basename(tlaSum)}` : "- TLA summary: n/a");
          lines.push(alloySum ? `- Alloy summary file: ${path.basename(alloySum)}` : "- Alloy summary: n/a");
          lines.push(smtSum ? `- SMT summary file: ${path.basename(smtSum)}` : "- SMT summary: n/a");
          if (apalacheSum && apalache) {
            const v = apalache.version || 'n/a';
            const ok = apalache.ok; // may be boolean or null
            const ran = apalache.ran;
            const status = apalache.status;
            const timeMs = apalache.timeMs || null;
            const toolPath = apalache.toolPath || '';
            const run = apalache.run || '';
            const ec = (typeof apalache.errorCount === 'number') ? apalache.errorCount : null;
            lines.push(`- Apalache: ran=${ran? 'yes':'no'} ok=${ok==null? 'n/a': (ok? 'yes':'no')} status=${status||'n/a'}${ec!=null?`, errors=${ec}`:''} (v=${v}${timeMs?`, ${Math.round(timeMs/1000)}s`:''})`);
            const hints=[];
            if (toolPath) hints.push(`tool: ${toolPath}`);
            if (run) hints.push(`run: ${run}`);
            if (apalacheOut) hints.push(`output: ${path.basename(apalacheOut)}`);
            if (hints.length) lines.push('  - ' + hints.join(' | '));
            if (ok === false && Array.isArray(apalache.errors) && apalache.errors.length > 0) {
              lines.push('');
              lines.push('<details><summary>Apalache errors (top)</summary>');
              lines.push('');
              lines.push('```text');
              for (const e of apalache.errors.slice(0,ERRORS_LIMIT)) lines.push(escMd(clamp(e)));
              lines.push('```');
              lines.push('');
              lines.push('</details>');
            }
            if (ok === false && apalache.errorSnippet && Array.isArray(apalache.errorSnippet.lines)) {
              const ctxLines = apalache.errorSnippet.lines.map(l => escMd(clamp(l)));
              if (ctxLines.length) {
                lines.push('');
                lines.push('- First error context:');
                lines.push('');
                lines.push('```text');
                for (const l of ctxLines) lines.push(l);
                lines.push('```');
              }
            }
          } else {
            lines.push("- Apalache summary: n/a");
          }
          lines.push(confSum ? `- Conformance summary file: ${path.basename(confSum)}` : "- Conformance summary: n/a");
          lines.push("");
          lines.push("_Non-blocking. Add/remove label run-formal to control._");
          lines.push("_Reproduce locally: pnpm run verify:tla -- --engine=apalache_ (see docs/quality/formal-runbook.md)");
          lines.push("_Tools check: pnpm run tools:formal:check_");
          lines.push(`_Clamp: line=${clampInfo.lineClamp}, errors=${clampInfo.errorsLimit}_`);
          const md = lines.join("\n");
          fs.writeFileSync(outMd, md);
          // JSON aggregate for tooling
          const json = {
            tlc: { ok: tlcOk, total: tlcTotal },
            alloy: { ok: alloyOk, total: alloyTotal, summary: alloyS || null },
            tla: tla || null,
            smt: smt || null,
            apalache: apalache || null,
            conformance: conf || null,
            info: { lineClamp: LINE_CLAMP, errorsLimit: ERRORS_LIMIT, generatedAt: new Date().toISOString() }
          };
          fs.writeFileSync(outJson, JSON.stringify(json,null,2));
          console.log(md);
          JS
      - name: Upload aggregate
        uses: actions/upload-artifact@v4
        with:
          name: formal-reports-aggregate
          path: artifacts/formal/formal-aggregate.md
      - name: Upload aggregate JSON
        uses: actions/upload-artifact@v4
        with:
          name: formal-reports-aggregate-json
          path: artifacts/formal/formal-aggregate.json
      - name: Comment on PR (upsert)
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const header = '<!-- AE-FORMAL-AGGREGATE -->\n';
            const body = header + fs.readFileSync('artifacts/formal/formal-aggregate.md','utf-8');
            const { owner, repo, number } = context.issue;
            const comments = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
            const mine = comments.data.find(c => c.body && c.body.startsWith('<!-- AE-FORMAL-AGGREGATE -->'));
            if (mine && mine.body === body) {
              core.info('Aggregate unchanged; skipping update');
            } else if (mine) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
            }
