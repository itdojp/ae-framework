name: Formal Reports Aggregate

on:
  pull_request:
    types: [opened, synchronize, reopened, labeled]
  workflow_dispatch:

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  aggregate:
    concurrency:
      group: formal-aggregate-${{ github.ref }}
      cancel-in-progress: true
    outputs:
      present_count: ${{ steps.export.outputs.present_count }}
      present_keys: ${{ steps.export.outputs.present_keys }}
      aggregate_json_present: ${{ steps.export.outputs.aggregate_json_present }}
      comment_action: ${{ steps.comment.outputs.comment_action }}
      comment_url: ${{ steps.comment.outputs.comment_url }}
      comment_reason: ${{ steps.comment.outputs.comment_reason }}
      has_run_formal: ${{ steps.labels.outputs.has_run_formal }}
    if: github.event_name == 'workflow_dispatch' || contains(github.event.pull_request.labels.*.name, 'run-formal')
    runs-on: ubuntu-latest
    continue-on-error: true
    env:
      FORMAL_AGG_LINE_CLAMP: ${{ vars.FORMAL_AGG_LINE_CLAMP || 200 }}
      FORMAL_AGG_ERRORS_LIMIT: ${{ vars.FORMAL_AGG_ERRORS_LIMIT || 5 }}
      FORMAL_AGG_SNIPPET_MAX_LINES: ${{ vars.FORMAL_AGG_SNIPPET_MAX_LINES || 20 }}
      FORMAL_AGG_WRAP_WIDTH: ${{ vars.FORMAL_AGG_WRAP_WIDTH || 0 }}
    steps:
      - uses: actions/checkout@v4
      - name: Download artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts_dl
      - name: Aggregate formal reports
        id: agg
        run: |
          node <<'JS'
          const fs=require("fs"), path=require("path");
          function rj(p){ try { return JSON.parse(fs.readFileSync(p,"utf-8")); } catch { return undefined; } }
          function find(dir, name){ try { const p = path.join(dir, name); return fs.existsSync(p) ? p : undefined; } catch { return undefined; } }
          const LINE_CLAMP = parseInt(process.env.FORMAL_AGG_LINE_CLAMP || '200', 10);
          const ERRORS_LIMIT = parseInt(process.env.FORMAL_AGG_ERRORS_LIMIT || '5', 10);
          const SNIPPET_MAX = parseInt(process.env.FORMAL_AGG_SNIPPET_MAX_LINES || '20', 10);
          const WRAP_WIDTH = parseInt(process.env.FORMAL_AGG_WRAP_WIDTH || '0', 10);
          function escMd(s){
            if (!s) return '';
            // Basic Markdown escaping to avoid breaking PR rendering
            return String(s)
              .replace(/`/g, "`\u200b")
              .replace(/</g, "&lt;")
              .replace(/>/g, "&gt;");
          }
          function clamp(s, n=LINE_CLAMP){ s = String(s||''); return s.length>n ? (s.slice(0,n)+"…") : s; }
          const base = "artifacts_dl";
          const outDir = "artifacts/formal"; fs.mkdirSync(outDir,{recursive:true});
          const outMd = path.join(outDir, "formal-aggregate.md");
          const outJson = path.join(outDir, "formal-aggregate.json");
          const GENERATED_AT = new Date().toISOString();
          const RUN_URL = `${process.env.GITHUB_SERVER_URL || 'https://github.com'}/${process.env.GITHUB_REPOSITORY || ''}/actions/runs/${process.env.GITHUB_RUN_ID || ''}`;

          const modelJson = find(base, "model-check-results/model-check.json");
          const alloy = modelJson ? (rj(modelJson)?.alloy || {}) : {};
          const tlc = modelJson ? (rj(modelJson)?.tlc || {}) : {};
          const alloyOk = Array.isArray(alloy.results) ? alloy.results.filter(x=>x?.ok===true).length : 0;
          const alloyTotal = Array.isArray(alloy.results) ? alloy.results.filter(x=>x?.ok!==undefined).length : 0;
          const tlcOk = Array.isArray(tlc.results) ? tlc.results.filter(x=>x?.ok===true).length : 0;
          const tlcTotal = Array.isArray(tlc.results) ? tlc.results.length : 0;

          const tlaSum = find(base, "formal-reports-tla/tla-summary.json");
          const alloySum = find(base, "formal-reports-alloy/alloy-summary.json");
          const smtSum = find(base, "formal-reports-smt/smt-summary.json");
          const apalacheSum = find(base, "formal-reports-apalache/apalache-summary.json");
          const apalacheOut = find(base, "formal-reports-apalache/apalache-output.txt");
          const confSum = find(base, "formal-reports-conformance/conformance-summary.json");

          const apalache = apalacheSum ? rj(apalacheSum) : undefined;
          const tla = tlaSum ? rj(tlaSum) : undefined;
          const smt = smtSum ? rj(smtSum) : undefined;
          const alloyS = alloySum ? rj(alloySum) : undefined;
          const conf = confSum ? rj(confSum) : undefined;
          const clampInfo = {
            lineClamp: process.env.FORMAL_AGG_LINE_CLAMP || '200',
            errorsLimit: process.env.FORMAL_AGG_ERRORS_LIMIT || '5',
            snippetMaxLines: process.env.FORMAL_AGG_SNIPPET_MAX_LINES || '20',
            wrapWidth: process.env.FORMAL_AGG_WRAP_WIDTH || '0'
          };

          const lines = [];
          lines.push("## 🔎 Formal Reports Aggregate");
          lines.push("");
          lines.push(`- TLC: ${tlcOk}/${tlcTotal} ok`);
          lines.push(`- Alloy: ${alloyOk}/${alloyTotal} ok`);
          lines.push(tlaSum ? `- TLA summary file: ${path.basename(tlaSum)}` : "- TLA summary: n/a");
          lines.push(alloySum ? `- Alloy summary file: ${path.basename(alloySum)}` : "- Alloy summary: n/a");
          if (alloyS && alloyS.temporal) {
            const t = alloyS.temporal;
            const ops = Array.isArray(t.operators) && t.operators.length ? ` (ops: ${t.operators.join(', ')})` : '';
            lines.push(`- Alloy temporal: ${t.present ? 'present' : 'absent'}${ops}`);
          }
          lines.push(smtSum ? `- SMT summary file: ${path.basename(smtSum)}` : "- SMT summary: n/a");
          if (smt) {
            const ss = [
              `solver=${smt.solver || 'n/a'}`,
              `status=${smt.status || 'n/a'}`
            ].join(' ');
            lines.push(`- SMT: ${ss}`);
          }
          if (conf && conf.runtimeHooks) {
            const h = conf.runtimeHooks;
            const info = `present=${h.present? 'yes':'no'} count=${h.count||0} traceId=${h.traceId||'n/a'} match=${h.matchesReplayTraceId? 'yes':'no'}`;
            lines.push(`- Runtime hooks: ${info}`);
          }
          // Present map (single source for MD + JSON)
          const present = {
            tla: !!tlaSum,
            alloy: !!alloySum,
            smt: !!smtSum,
            apalache: !!apalacheSum,
            conformance: !!confSum
          };
          // Quick one-line present/ran summary（MD表示とJSONのpresentを完全同期）
          const order = ['tla','alloy','smt','apalache','conformance'];
          const presentKeys = order.filter(k => present[k]);
          const presentCount = presentKeys.length;
          const apLine = apalacheSum && apalache ? `ran=${apalache.ran? 'yes':'no'} ok=${apalache.ok==null? 'n/a': (apalache.ok? 'yes':'no')}` : 'n/a';
          // Optional one-line digest at the top for quick glance
          const digest = `Formal aggregate: Present ${presentCount}/5${presentCount ? ` (${presentKeys.join(', ')})` : ''} | Apalache ${apLine}`;
          lines.unshift("");
          lines.unshift(digest);
          lines.push('### Presence');
          lines.push(`Present: ${presentCount}/5${presentCount? ` (${presentKeys.join(', ')})` : ''}`);
          // Alloy temporal operator presence (if summary includes it)
          try {
            const t = alloyS && alloyS.temporal;
            if (t && (t.present || (Array.isArray(t.operators) && t.operators.length))) {
              const ops = Array.isArray(t.operators) ? t.operators.join(', ') : '';
              const pops = Array.isArray(t.pastOperators) ? t.pastOperators.join(', ') : '';
              lines.push(`Alloy temporal: present=${!!t.present}${ops? ` ops=[${ops}]`:''}${pops? ` past=[${pops}]`:''}`);
            }
          } catch {}
          // Apalache ran/ok line（MDとJSONの両方で一貫表記）
          lines.push(`Apalache ran/ok: ${apalacheSum && apalache ? (apalache.ran? 'yes':'no') : 'n/a'}/${apalacheSum && apalache ? (apalache.ok==null? 'n/a' : (apalache.ok? 'yes':'no')) : 'n/a'}`);
          lines.push("");
          // Visual separation for presence block
          lines.push("\n---");

          if (apalacheSum && apalache) {
            const v = apalache.version || 'n/a';
            const ok = apalache.ok; // may be boolean or null
            const ran = apalache.ran;
            const status = apalache.status;
            const timeMs = apalache.timeMs || null;
            const toolPath = apalache.toolPath || '';
            const run = apalache.run || '';
            const ec = (typeof apalache.errorCount === 'number') ? apalache.errorCount : null;
            lines.push(`- Apalache: ran=${ran? 'yes':'no'} ok=${ok==null? 'n/a': (ok? 'yes':'no')} status=${status||'n/a'}${ec!=null?`, errors=${ec}`:''} (v=${v}${timeMs?`, ${Math.round(timeMs/1000)}s`:''})`);
            const hints=[];
            if (toolPath) hints.push(`tool: ${toolPath}`);
            if (run) hints.push(`run: ${run}`);
            if (apalacheOut) hints.push(`output: ${path.basename(apalacheOut)}`);
            if (hints.length) lines.push('  - ' + hints.join(' | '));
            if (ok === false && Array.isArray(apalache.errors) && apalache.errors.length > 0) {
              lines.push('');
              lines.push('<details><summary>Apalache errors (top)</summary>');
              lines.push('');
              lines.push('```text');
              for (const e of apalache.errors.slice(0,ERRORS_LIMIT)) lines.push(escMd(clamp(e)));
              lines.push('```');
              lines.push('');
              lines.push('</details>');
            }
            if (ok === false && apalache.errorSnippet && Array.isArray(apalache.errorSnippet.lines)) {
              const MAX_LINES = SNIPPET_MAX;
              const ctxAll = apalache.errorSnippet.lines.map(l => escMd(clamp(l))).filter(l => String(l).trim().length>0);
              const ctxLines = ctxAll.slice(0, Math.max(0, MAX_LINES));
              if (ctxLines.length) {
                lines.push('');
                lines.push('- First error context:');
                lines.push('');
                lines.push('```text');
                for (const l of ctxLines) lines.push(l);
                lines.push('```');
              }
            }
          } else {
            lines.push("- Apalache summary: n/a");
          }
          lines.push(confSum ? `- Conformance summary file: ${path.basename(confSum)}` : "- Conformance summary: n/a");
          // By-type/present summary（簡潔・Present行の補助、一行で整形）
          // Deterministic by-type present line (JSON→MDと順序を完全同期)
          const presentList = ['tla','alloy','smt','apalache','conformance'].filter(k => present[k]);
          lines.push(`By-type present: ${presentList.length}/5${presentList.length? ` (${presentList.join(', ')})` : ''}`);
          if (apalacheSum && apalache) {
            lines.push(`Ran/OK summary: apalache ran=${apalache.ran? 'yes':'no'} ok=${apalache.ok==null? 'n/a': (apalache.ok? 'yes':'no')}`);
          }
          lines.push("");
          // Footer meta（順序を統一: Tools → Reproduce → Policy → Clamp → Generated）
          lines.push("\n---");
          lines.push("_Tools check: pnpm run tools:formal:check_");
          lines.push("_Reproduce locally: pnpm run verify:tla -- --engine=apalache_ (see docs/quality/formal-runbook.md)");
          lines.push("_Non-blocking. Add/remove label run-formal to control._");
          lines.push(`_Clamp: line=${clampInfo.lineClamp}, errors=${clampInfo.errorsLimit}, snippet=${clampInfo.snippetMaxLines}, wrap=${clampInfo.wrapWidth}_`);
          lines.push(`_Generated: ${GENERATED_AT}_`);
          if (process.env.GITHUB_RUN_ID) lines.push(`_Run: ${RUN_URL}_`);
          // Normalize markdown: collapse excessive empty lines + optional long-line wrap (outside code fences)
          function normalizeMd(arr){
            const out=[]; let prevEmpty=false; let inFence=false;
            const wrapWidth = WRAP_WIDTH; // 0=disable
            for (let raw of arr){
              let l = String(raw).replace(/\s+$/,''); // trim trailing spaces
              if (l.startsWith('```')) inFence = !inFence; // toggle on code fences
              if (!inFence && wrapWidth > 0 && l.length > wrapWidth){
                // wrap at spaces without breaking words
                const wrapped = [];
                let s = l;
                while (s.length > wrapWidth){
                  let cut = s.lastIndexOf(' ', wrapWidth);
                  if (cut < 0) cut = wrapWidth;
                  wrapped.push(s.slice(0, cut));
                  s = s.slice(cut).replace(/^\s+/, '');
                }
                if (s.length) wrapped.push(s);
                l = wrapped.join('\n');
              }
              const isEmpty = l.trim().length===0;
              if (isEmpty && prevEmpty) continue; // collapse multiple blanks
              out.push(l);
              prevEmpty = isEmpty;
            }
            const joined = out.join("\n");
            return joined
              .replace(/\n{3,}/g, "\n\n")
              .replace(/\n+$/, "\n");
          }
          // JSON aggregate for tooling（single source of truth for present/by-type）
          const json = {
            tlc: { ok: tlcOk, total: tlcTotal },
            alloy: { ok: alloyOk, total: alloyTotal, summary: alloyS || null },
            tla: tla || null,
            smt: smt || null,
            apalache: apalache || null,
            conformance: conf || null,
            info: { 
              lineClamp: LINE_CLAMP, 
              errorsLimit: ERRORS_LIMIT, 
              snippetMaxLines: SNIPPET_MAX,
              wrapWidth: WRAP_WIDTH,
              generatedAt: GENERATED_AT, 
              present, 
              presentCount,
              presentKeys,
              ranOk: {
                apalache: apalache ? { ran: !!apalache.ran, ok: (typeof apalache.ok === 'boolean' ? apalache.ok : null) } : null
              },
              temporal: {
                alloy: alloyS && alloyS.temporal ? alloyS.temporal : null
              }
            }
          };
          // Append an explicit consistency line referencing JSON info.present
          lines.push(`Consistency: MD=JSON present (${presentCount}/5)`);
          lines.push('_Source: info.present (aggregate JSON)_');
          const md = normalizeMd(lines);
          fs.writeFileSync(outMd, md);
          fs.writeFileSync(outJson, JSON.stringify(json,null,2));
          const aggPresent = fs.existsSync(outJson) ? 'yes' : 'no';
          console.log(md + "\nArtifacts: aggregate-json=" + aggPresent);
          JS
      - name: Upload aggregate
        uses: actions/upload-artifact@v4
        with:
          name: formal-reports-aggregate
          path: artifacts/formal/formal-aggregate.md
      - name: Upload aggregate JSON
        uses: actions/upload-artifact@v4
        with:
          name: formal-reports-aggregate-json
          path: artifacts/formal/formal-aggregate.json
      - name: Label status (run-formal)
        id: labels
        if: github.event_name == 'pull_request'
        run: |
          HAS=0
          if [ -f "$GITHUB_EVENT_PATH" ]; then \
            if jq -e '.pull_request.labels[]?.name | select(.=="run-formal")' "$GITHUB_EVENT_PATH" >/dev/null; then HAS=1; fi; \
          fi; \
          printf "%s\n" "has_run_formal=$HAS" >> "$GITHUB_OUTPUT"
      - name: Export aggregate outputs (present)
        id: export
        if: always()
        run: |
          if [ -f artifacts/formal/formal-aggregate.json ]; then \
            P=$(jq -r '.info.presentCount // 0' artifacts/formal/formal-aggregate.json 2>/dev/null || printf "0\n"); \
            KEYS=$(jq -r '(.info.presentKeys // (.info.present | to_entries | map(select(.value)) | map(.key))) | join(",")' artifacts/formal/formal-aggregate.json 2>/dev/null || printf "\n"); \
            printf "%s\n" "present_count=$P" >> "$GITHUB_OUTPUT"; \
            printf "%s\n" "present_keys=$KEYS" >> "$GITHUB_OUTPUT"; \
            printf "%s\n" "aggregate_json_present=true" >> "$GITHUB_OUTPUT"; \
          else \
            printf "%s\n" "aggregate_json_present=false" >> "$GITHUB_OUTPUT"; \
          fi
      - name: Validate aggregate JSON (non-blocking)
        if: always()
        run: |
          node scripts/formal/validate-aggregate-json.mjs || true
      - name: Validate conformance summary (non-blocking)
        if: always()
        run: |
          node scripts/formal/validate-conformance-summary.mjs || true
      - name: Append job summary (present)
        if: always()
        run: |
          printf "### Formal Aggregate\n" >> "$GITHUB_STEP_SUMMARY"
          if [ -f artifacts/formal/formal-aggregate.json ]; then \
            P=$(jq -r '.info.presentCount // 0' artifacts/formal/formal-aggregate.json 2>/dev/null || printf "0\n"); \
            KEYS=$(jq -r '.info.present | to_entries | map(select(.value)) | map(.key) | join(", ")' artifacts/formal/formal-aggregate.json 2>/dev/null || printf "\n"); \
            APO=$(jq -r 'try .info.ranOk.apalache as $a | ("ran=" + (if $a.ran then "yes" else "no" end) + " ok=" + (if ($a.ok==true) then "yes" else (if ($a.ok==false) then "no" else "n/a" end) end)) catch "n/a"' artifacts/formal/formal-aggregate.json 2>/dev/null || printf "n/a\n"); \
            if jq -e '.conformance != null' artifacts/formal/formal-aggregate.json >/dev/null 2>&1; then \
              CSE=$(jq -r '.conformance.schemaErrors // "n/a"' artifacts/formal/formal-aggregate.json); \
              CIV=$(jq -r '.conformance.invariantViolations // "n/a"' artifacts/formal/formal-aggregate.json); \
              CVR=$(jq -r '.conformance.violationRate // "n/a"' artifacts/formal/formal-aggregate.json); \
              CLN=$(printf "Conformance: schemaErrors=%s, invariantViolations=%s, rate=%s" "$CSE" "$CIV" "$CVR"); \
            else \
              CLN="Conformance: n/a"; \
            fi; \
            printf "Present: %s/5\n" "$P" >> "$GITHUB_STEP_SUMMARY"; \
            if [ -n "$KEYS" ]; then printf "Keys: %s\n" "$KEYS" >> "$GITHUB_STEP_SUMMARY"; fi; \
            printf "Apalache: %s\n" "$APO" >> "$GITHUB_STEP_SUMMARY"; \
            printf "Digest: Present %s/5 | Apalache %s\n" "$P" "$APO" >> "$GITHUB_STEP_SUMMARY"; \
            printf "%s\n" "$CLN" >> "$GITHUB_STEP_SUMMARY"; \
            printf "Artifacts: artifacts/formal/formal-aggregate.{md,json}\n" >> "$GITHUB_STEP_SUMMARY"; \
          else \
            printf "No aggregate JSON found (artifacts/formal/formal-aggregate.json)\n" >> "$GITHUB_STEP_SUMMARY"; \
          fi; \
          printf "Header: <!-- AE-FORMAL-AGGREGATE --> (upsert on pull_request with label run-formal)\n" >> "$GITHUB_STEP_SUMMARY"
          printf "Docs: docs/quality/formal-aggregate-comment.md\n" >> "$GITHUB_STEP_SUMMARY"
          printf "Runbook: docs/quality/formal-runbook.md\n" >> "$GITHUB_STEP_SUMMARY"; \
          printf "Run: %s/%s/actions/runs/%s\n" \
            "${GITHUB_SERVER_URL:-https://github.com}" "${GITHUB_REPOSITORY}" "${GITHUB_RUN_ID}" >> "$GITHUB_STEP_SUMMARY"
          printf "Clamp: line=%s, errors=%s, snippet=%s, wrap=%s\n" \
            "${FORMAL_AGG_LINE_CLAMP:-200}" \
            "${FORMAL_AGG_ERRORS_LIMIT:-5}" \
            "${FORMAL_AGG_SNIPPET_MAX_LINES:-20}" \
            "${FORMAL_AGG_WRAP_WIDTH:-0}" >> "$GITHUB_STEP_SUMMARY"; \
          if [ "${{ steps.labels.outputs.has_run_formal }}" = "1" ]; then \
            printf "Label run-formal: yes\n" >> "$GITHUB_STEP_SUMMARY"; \
          else \
            printf "Label run-formal: no\n" >> "$GITHUB_STEP_SUMMARY"; \
          fi
      - name: Note (dispatch vs PR comment)
        if: github.event_name != 'pull_request'
        run: |
          printf "%s\n" "Event: $GITHUB_EVENT_NAME (no PR comment will be posted)." \
          && printf "%s\n" "Artifacts generated under artifacts/formal/. Comment upsert runs only on pull_request with label run-formal."
      - name: Comment on PR (upsert)
        if: github.event_name == 'pull_request' && steps.labels.outputs.has_run_formal == '1'
        id: comment
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const header = '<!-- AE-FORMAL-AGGREGATE -->\n';
            const mdPath = 'artifacts/formal/formal-aggregate.md';
            const jsonPath = 'artifacts/formal/formal-aggregate.json';
            let action = 'skipped';
            let reason = '';
            let url = '';
            let commentPresent = false;
            if (!fs.existsSync(mdPath)) {
              reason = 'no-md';
              core.info('No aggregate MD found; skipping PR comment upsert');
            } else if (!fs.existsSync(jsonPath)) {
              reason = 'no-json';
              core.info('No aggregate JSON found; skipping PR comment upsert');
            } else {
              try {
                const body = header + fs.readFileSync(mdPath,'utf-8');
                const { owner, repo, number } = context.issue;
                const comments = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
                const mine = comments.data.find(c => c.body && c.body.startsWith('<!-- AE-FORMAL-AGGREGATE -->'));
                if (mine) commentPresent = true;
                if (mine && mine.body === body) {
                  core.info('Aggregate unchanged; skipping update');
                  action = 'skipped';
                  reason = 'unchanged';
                } else if (mine) {
                  const res = await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body });
                  url = res?.data?.html_url || '';
                  action = 'updated';
                  commentPresent = true;
                } else {
                  const res = await github.rest.issues.createComment({ owner, repo, issue_number: number, body });
                  url = res?.data?.html_url || '';
                  action = 'created';
                  commentPresent = true;
                }
              } catch (e) {
                core.warning(`Upsert failed: ${e?.message || e}`);
                action = 'skipped';
                reason = 'api-error';
              }
            }
            core.setOutput('comment_action', action);
            if (reason) core.setOutput('comment_reason', reason);
            if (url) core.setOutput('comment_url', url);
            core.setOutput('comment_present', commentPresent ? '1' : '0');
      - name: Append comment action to summary
        if: github.event_name == 'pull_request'
        run: |
          printf "Comment: %s\n" "${{ steps.comment.outputs.comment_action || 'n/a' }}" >> "$GITHUB_STEP_SUMMARY"
          if [ -n "${{ steps.comment.outputs.comment_url }}" ]; then \
            printf "Comment URL: %s\n" "${{ steps.comment.outputs.comment_url }}" >> "$GITHUB_STEP_SUMMARY"; \
          fi
          if [ -n "${{ steps.comment.outputs.comment_reason }}" ]; then \
            printf "Comment reason: %s\n" "${{ steps.comment.outputs.comment_reason }}" >> "$GITHUB_STEP_SUMMARY"; \
          fi
          if [ "${{ steps.comment.outputs.comment_present }}" = "1" ]; then \
            printf "Comment present: yes\n" >> "$GITHUB_STEP_SUMMARY"; \
          else \
            printf "Comment present: no\n" >> "$GITHUB_STEP_SUMMARY"; \
          fi
