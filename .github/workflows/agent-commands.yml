name: agent-commands

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  handle:
    if: github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: Parse and apply agent commands
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body.trim();
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;

            const addLabels = async (labels) => {
              if (!labels || labels.length === 0) return;
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels });
            };
            const removeLabel = async (label) => {
              try { await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label }); } catch {}
            };
            const removeLabelsByPrefix = async (prefix) => {
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number, per_page: 100 });
              const targets = labels.map(l=>l.name).filter(n => n.startsWith(prefix));
              for (const name of targets) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number, name }); } catch {}
              }
            };

            const reply = async (msg) => {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: `<!-- AE-AGENTS-REPLY -->\n${msg}` });
            };

            // Supported commands:
            // /run-qa, /run-security, /non-blocking, /ready, /pr-digest, /pr-detailed
            // /handoff A|B|C
            // Dispatchers (require workflow_dispatch on target):
            // /verify-lite, /run-qa-dispatch, /run-security-dispatch, /ci-fast-dispatch, /formal-verify-dispatch
            // /run-flake-dispatch, /spec-validation-dispatch
            const cmd = body.split(/\s+/)[0];
            const arg = body.split(/\s+/)[1] || '';

            switch (cmd) {
              case '/run-qa':
                await addLabels(['run-qa']);
                return reply('Label `run-qa` added. ae-ci will execute QA step.');
              case '/run-security':
                await addLabels(['run-security']);
                return reply('Label `run-security` added. Security/SBOM workflows will run.');
              case '/non-blocking':
                await addLabels(['ci-non-blocking']);
                return reply('Label `ci-non-blocking` added. Some jobs will continue-on-error.');
              case '/blocking':
                await removeLabel('ci-non-blocking');
                return reply('Label `ci-non-blocking` removed. Jobs will be blocking as configured.');
              case '/ready':
                await removeLabel('do-not-merge');
                return reply('Label `do-not-merge` removed. PR is ready for merge gates.');
              case '/run-hermetic':
                await addLabels(['run-hermetic']);
                return reply('Label `run-hermetic` added. Hermetic CI will run for this PR.');
              case '/run-spec':
                await addLabels(['run-spec']);
                return reply('Label `run-spec` added. Fail-fast spec validation will run.');
              case '/run-drift':
                await addLabels(['run-drift']);
                return reply('Label `run-drift` added. Codegen drift detection will run.');
              case '/enforce-typecov':
                await addLabels(['enforce-typecov']);
                return reply('Label `enforce-typecov` added. Type coverage threshold enforcement may apply.');
              case '/coverage': {
                const v = (arg || '').trim();
                if (v.toLowerCase() === 'clear') {
                  await removeLabelsByPrefix('coverage:');
                  return reply('Cleared coverage:* labels.');
                }
                if (!/^\d{1,3}$/.test(v)) return reply('Usage: `/coverage <pct|clear>` (e.g., `/coverage 72`)');
                const n = Number(v);
                if (n < 0 || n > 100) return reply('Coverage percent must be 0..100');
                await removeLabelsByPrefix('coverage:');
                await addLabels([`coverage:${n}`]);
                return reply(`Label \`coverage:${n}\` set. Coverage check will use this threshold.`);
              }
              case '/enforce-coverage': {
                await addLabels(['enforce-coverage']);
                return reply('Label `enforce-coverage` added. Coverage gate will be enforced.');
              }
              case '/pr-digest':
                await addLabels(['pr-summary:digest']);
                return reply('Label `pr-summary:digest` added. Digest summary will be posted.');
              case '/pr-detailed':
                await addLabels(['pr-summary:detailed']);
                return reply('Label `pr-summary:detailed` added. Detailed summary will be posted.');
              case '/handoff': {
                const m = (arg || '').toUpperCase();
                if (['A','B','C'].includes(m)) {
                  await addLabels([`handoff:agent-${m.toLowerCase()}`]);
                  return reply(`Handoff queued for Agent ${m}.`);
                }
                return reply('Usage: `/handoff A|B|C`');
              }
              case '/verify-lite': {
                // Dispatch verify-lite on PR head
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'verify-lite.yml', ref });
                return reply(`Dispatched verify-lite on ${ref}`);
              }
              case '/run-qa-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'ae-ci.yml', ref });
                return reply(`Dispatched ae-ci (QA) on ${ref}`);
              }
              case '/run-security-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'sbom-generation.yml', ref, inputs: { include_vulnerabilities: 'true' } });
                return reply(`Dispatched sbom-generation (security) on ${ref}`);
              }
              case '/ci-fast-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'ci-fast.yml', ref });
                return reply(`Dispatched CI Fast on ${ref}`);
              }
              case '/formal-verify-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'formal-verify.yml', ref });
                return reply(`Dispatched Formal Verify on ${ref}`);
              }
              case '/run-flake-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'flake-detect.yml', ref });
                return reply(`Dispatched flake-detect on ${ref}`);
              }
              case '/spec-validation-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'spec-validation.yml', ref });
                return reply(`Dispatched spec-validation on ${ref}`);
              }
              case '/qa-batch-commands':
              case '/run-qa:commands': {
                await addLabels(['qa-batch:commands']);
                return reply('Label `qa-batch:commands` added. Commands tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-cli':
              case '/run-qa:cli': {
                await addLabels(['qa-batch:cli']);
                return reply('Label `qa-batch:cli` added. CLI tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-property':
              case '/run-qa:property': {
                await addLabels(['qa-batch:property']);
                return reply('Label `qa-batch:property` added. Property-based tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-agents':
              case '/run-qa:agents': {
                await addLabels(['qa-batch:agents']);
                return reply('Label `qa-batch:agents` added. Agents tests will run in CI Fast (opt-in).');
              }
              case '/run-formal': {
                await addLabels(['run-formal']);
                return reply('Label `run-formal` added. Formal jobs will run (non-blocking, opt-in).');
              }
              case '/enforce-formal': {
                await addLabels(['enforce-formal']);
                return reply('Label `enforce-formal` added. Formal enforcement may apply if configured.');
              }
              case '/enforce-contracts': {
                await addLabels(['enforce-contracts']);
                return reply('Label `enforce-contracts` added. Contracts enforcement may apply if configured.');
              }
              default:
                return; // ignore
            }
