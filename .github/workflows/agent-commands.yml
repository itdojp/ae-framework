name: agent-commands

on:
  issue_comment:
    types: [created]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  handle:
    if: github.event.issue.pull_request
    runs-on: ubuntu-latest
    steps:
      - name: Parse and apply agent commands
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.comment.body.trim();
            const { owner, repo } = context.repo;
            const issue_number = context.issue.number;

            const addLabels = async (labels) => {
              if (!labels || labels.length === 0) return;
              await github.rest.issues.addLabels({ owner, repo, issue_number, labels });
            };
            const removeLabel = async (label) => {
              try { await github.rest.issues.removeLabel({ owner, repo, issue_number, name: label }); } catch {}
            };
            const removeLabelsByPrefix = async (prefix) => {
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number, per_page: 100 });
              const targets = labels.map(l=>l.name).filter(n => n.startsWith(prefix));
              for (const name of targets) {
                try { await github.rest.issues.removeLabel({ owner, repo, issue_number, name }); } catch {}
              }
            };

            const reply = async (msg) => {
              await github.rest.issues.createComment({ owner, repo, issue_number, body: `<!-- AE-AGENTS-REPLY -->\n${msg}` });
            };

            // Supported commands:
            // /run-qa, /run-security, /non-blocking, /ready, /pr-digest, /pr-detailed
            // /handoff A|B|C
            // Dispatchers (require workflow_dispatch on target):
            // /verify-lite, /run-qa-dispatch, /run-security-dispatch, /ci-fast-dispatch, /formal-verify-dispatch
            // /formal-apalache-dispatch, /run-flake-dispatch, /spec-validation-dispatch
            // /formal-aggregate-dispatch (aggregate workflow_dispatch)
            // /formal-help (prints quick tips and docs links)
            // /formal-quickstart (alias of /formal-help)
            const cmd = body.split(/\s+/)[0];
            const arg = body.split(/\s+/)[1] || '';

            switch (cmd) {
              case '/enforce-bdd-lint':
                await addLabels(['enforce-bdd-lint']);
                return reply('Label `enforce-bdd-lint` added. BDD lint will be enforced (blocking) in verify-lite.');
              case '/formal-help': {
                const tips = [
                  '### Formal Help',
                  '',
                  '- Tools check: `pnpm run tools:formal:check`',
                  '- Apalache: `pnpm run verify:tla -- --engine=apalache`',
                  '- TLC: `TLA_TOOLS_JAR=/path/to/tla2tools.jar pnpm run verify:tla -- --engine=tlc`',
                  '- SMT: `pnpm run verify:smt -- --solver=z3 --file spec/smt/sample.smt2`',
                  '',
                  'Docs: `docs/quality/formal-runbook.md`, `docs/quality/formal-tools-setup.md`'
                ].join('\n');
                return reply(tips);
              }
              case '/run-qa':
                await addLabels(['run-qa']);
                return reply('Label `run-qa` added. ae-ci will execute QA step.');
              case '/run-security':
                await addLabels(['run-security']);
                return reply('Label `run-security` added. Security/SBOM workflows will run.');
              case '/run-cedar':
                await addLabels(['run-cedar']);
                return reply('Label `run-cedar` added. Cedar policies quality gates will run (report-only).');
              case '/non-blocking':
                await addLabels(['ci-non-blocking']);
                return reply('Label `ci-non-blocking` added. Some jobs will continue-on-error.');
              case '/blocking':
                await removeLabel('ci-non-blocking');
                return reply('Label `ci-non-blocking` removed. Jobs will be blocking as configured.');
              case '/ready':
                await removeLabel('do-not-merge');
                return reply('Label `do-not-merge` removed. PR is ready for merge gates.');
              case '/run-hermetic':
                await addLabels(['run-hermetic']);
                return reply('Label `run-hermetic` added. Hermetic CI will run for this PR.');
              case '/run-spec':
                await addLabels(['run-spec']);
                return reply('Label `run-spec` added. Fail-fast spec validation will run.');
              case '/run-drift':
                await addLabels(['run-drift']);
                return reply('Label `run-drift` added. Codegen drift detection will run.');
              case '/enforce-typecov':
                await addLabels(['enforce-typecov']);
                return reply('Label `enforce-typecov` added. Type coverage threshold enforcement may apply.');
              case '/coverage': {
                const v = (arg || '').trim();
                if (v.toLowerCase() === 'clear') {
                  await removeLabelsByPrefix('coverage:');
                  return reply('Cleared coverage:* labels.');
                }
                if (!/^\d{1,3}$/.test(v)) return reply('Usage: `/coverage <pct|clear>` (e.g., `/coverage 72`)');
                const n = Number(v);
                if (n < 0 || n > 100) return reply('Coverage percent must be 0..100');
                await removeLabelsByPrefix('coverage:');
                await addLabels([`coverage:${n}`]);
                return reply(`Label \`coverage:${n}\` set. Coverage check will use this threshold.`);
              }
              case '/enforce-coverage': {
                await addLabels(['enforce-coverage']);
                return reply('Label `enforce-coverage` added. Coverage gate will be enforced.');
              }
              case '/pr-digest':
                await addLabels(['pr-summary:digest']);
                return reply('Label `pr-summary:digest` added. Digest summary will be posted.');
              case '/pr-detailed':
                await addLabels(['pr-summary:detailed']);
                return reply('Label `pr-summary:detailed` added. Detailed summary will be posted.');
              case '/handoff': {
                const m = (arg || '').toUpperCase();
                if (['A','B','C'].includes(m)) {
                  await addLabels([`handoff:agent-${m.toLowerCase()}`]);
                  return reply(`Handoff queued for Agent ${m}.`);
                }
                return reply('Usage: `/handoff A|B|C`');
              }
              case '/verify-lite': {
                // Dispatch verify-lite on PR head
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'verify-lite.yml', ref });
                return reply(`Dispatched verify-lite on ${ref}`);
              }
              case '/run-qa-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'ae-ci.yml', ref });
                return reply(`Dispatched ae-ci (QA) on ${ref}`);
              }
              case '/run-security-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'sbom-generation.yml', ref, inputs: { include_vulnerabilities: 'true' } });
                return reply(`Dispatched sbom-generation (security) on ${ref}`);
              }
              case '/ci-fast-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'ci-fast.yml', ref });
                return reply(`Dispatched CI Fast on ${ref}`);
              }
              case '/formal-verify-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'formal-verify.yml', ref });
                return reply(`Dispatched Formal Verify on ${ref}`);
              }
              case '/formal-apalache-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'formal-verify.yml', ref, inputs: { target: 'apalache' } });
                return reply(`Dispatched Formal Verify (Apalache) on ${ref}`);
              }
              case '/run-flake-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'flake-detect.yml', ref });
                return reply(`Dispatched flake-detect on ${ref}`);
              }
              case '/spec-validation-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'spec-validation.yml', ref });
                return reply(`Dispatched spec-validation on ${ref}`);
              }
              case '/formal-aggregate-dispatch': {
                if (!context.payload.issue.pull_request) return reply('Not a PR');
                const pr = await github.rest.pulls.get({ owner, repo, pull_number: issue_number });
                const ref = pr.data.head.ref;
                const header = '<!-- AE-FORMAL-AGGREGATE -->';
                const comments = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 100 });
                const mine = comments.data.find(c => c.body && c.body.startsWith(header));
                const last = mine ? (mine.updated_at || mine.created_at) : null;
                let hasAggArtifacts = false;
                try {
                  const arts = await github.rest.actions.listArtifactsForRepo({ owner, repo, per_page: 100 });
                  hasAggArtifacts = arts.data.artifacts?.some(a => a?.name === 'formal-reports-aggregate-json' || a?.name === 'formal-reports-aggregate') || false;
                } catch {}
                await github.rest.actions.createWorkflowDispatch({ owner, repo, workflow_id: 'formal-aggregate.yml', ref });
                const lines = [];
                lines.push(`Dispatched formal-aggregate on ${ref}`);
                if (last) lines.push(`- last post: ${new Date(last).toISOString()}`); else lines.push('- last post: n/a');
                lines.push(`- last artifacts present: ${hasAggArtifacts ? 'yes' : 'no'}`);
                lines.push('');
                lines.push('- Clamp env: FORMAL_AGG_LINE_CLAMP (default 200), FORMAL_AGG_ERRORS_LIMIT (default 5)');
                lines.push('- Artifacts: formal-reports-aggregate, formal-reports-aggregate-json');
                return reply(lines.join('\n'));
              }
              case '/qa-batch-commands':
              case '/run-qa:commands': {
                await addLabels(['qa-batch:commands']);
                return reply('Label `qa-batch:commands` added. Commands tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-cli':
              case '/run-qa:cli': {
                await addLabels(['qa-batch:cli']);
                return reply('Label `qa-batch:cli` added. CLI tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-property':
              case '/run-qa:property': {
                await addLabels(['qa-batch:property']);
                return reply('Label `qa-batch:property` added. Property-based tests will run in CI Fast (opt-in).');
              }
              case '/qa-batch-agents':
              case '/run-qa:agents': {
                await addLabels(['qa-batch:agents']);
                return reply('Label `qa-batch:agents` added. Agents tests will run in CI Fast (opt-in).');
              }
              case '/run-adapters': {
                await addLabels(['run-adapters']);
                return reply('Label `run-adapters` added. Adapter thresholds (report-only) will run.');
              }
              case '/enforce-perf': {
                await addLabels(['enforce-perf']);
                return reply('Label `enforce-perf` added. Performance threshold enforcement may apply.');
              }
              case '/enforce-lh': {
                await addLabels(['enforce-lh']);
                return reply('Label `enforce-lh` added. Lighthouse threshold enforcement may apply.');
              }
              case '/perf': {
                const v = (arg || '').trim();
                if (v.toLowerCase() === 'clear') {
                  await removeLabelsByPrefix('perf:');
                  return reply('Cleared perf:* labels.');
                }
                if (!/^\d{1,3}$/.test(v)) return reply('Usage: `/perf <pct|clear>` (e.g., `/perf 75`)');
                const n = Number(v);
                if (n < 0 || n > 100) return reply('Perf percent must be 0..100');
                await removeLabelsByPrefix('perf:');
                await addLabels([`perf:${n}`]);
                return reply(`Label \`perf:${n}\` set. Performance check will use this threshold.`);
              }
              case '/lh': {
                const v = (arg || '').trim();
                if (v.toLowerCase() === 'clear') {
                  await removeLabelsByPrefix('lh:');
                  return reply('Cleared lh:* labels.');
                }
                if (!/^\d{1,3}$/.test(v)) return reply('Usage: `/lh <pct|clear>` (e.g., `/lh 80`)');
                const n = Number(v);
                if (n < 0 || n > 100) return reply('Lighthouse percent must be 0..100');
                await removeLabelsByPrefix('lh:');
                await addLabels([`lh:${n}`]);
                return reply(`Label \`lh:${n}\` set. Lighthouse check will use this threshold.`);
              }
              case '/enforce-a11y': {
                await addLabels(['enforce-a11y']);
                return reply('Label `enforce-a11y` added. Adapter thresholds will be enforced (a11y critical/serious=0).');
              }
              case '/run-formal': {
                await addLabels(['run-formal']);
                return reply('Label `run-formal` added. Formal jobs will run (non-blocking, opt-in).');
              }
              case '/enforce-formal': {
                await addLabels(['enforce-formal']);
                return reply('Label `enforce-formal` added. Formal enforcement may apply if configured.');
              }
              case '/enforce-contracts': {
                await addLabels(['enforce-contracts']);
                return reply('Label `enforce-contracts` added. Contracts enforcement may apply if configured.');
              }
              case '/formal-quickstart': {
                const tips = [
                  '### Formal Quickstart',
                  '',
                  '- Tools check: `pnpm run tools:formal:check`',
                  '- Apalache: `pnpm run verify:tla -- --engine=apalache`',
                  '- TLC: `TLA_TOOLS_JAR=/path/to/tla2tools.jar pnpm run verify:tla -- --engine=tlc`',
                  '- SMT: `pnpm run verify:smt -- --solver=z3 --file spec/smt/sample.smt2`',
                  '',
                  'Docs: `docs/quality/formal-runbook.md`, `docs/quality/formal-tools-setup.md`'
                ].join('\n');
                return reply(tips);
              }
              default:
                return; // ignore
            }
