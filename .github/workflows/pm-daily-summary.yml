name: PM Daily Summary

on:
  schedule:
    - cron: '30 23 * * *' # 08:30 JST daily
  workflow_dispatch:
    inputs:
      force:
        description: 'Force run now'
        required: false
        default: 'true'

permissions:
  contents: read
  issues: write
  pull-requests: read

env:
  ROOT_ISSUE: '898'
  POLICY_ISSUE: '963'
  CHILD_ISSUES: '958,959,960,961,962,963,964'
  DAILY_HEADER: '<!-- AE-PM-DAILY -->'

jobs:
  summarize:
    runs-on: ubuntu-latest
    steps:
      - name: Summarize Sprint 0 status and upsert comment
        uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const ROOT_ISSUE = process.env.ROOT_ISSUE;
            const POLICY_ISSUE = process.env.POLICY_ISSUE;
            const CHILD_ISSUES = process.env.CHILD_ISSUES.split(',').map(s => s.trim()).filter(Boolean);
            const HEADER = process.env.DAILY_HEADER;

            async function ensureStartOnPolicyIssue() {
              try {
                const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: Number(POLICY_ISSUE), per_page: 100 });
                const hasStart = comments.some(c => (c.body || '').includes('/start'));
                if (!hasStart) {
                  await github.rest.issues.createComment({ owner, repo, issue_number: Number(POLICY_ISSUE), body: '/start' });
                }
              } catch (e) {
                core.warning(`Failed to ensure /start on #${POLICY_ISSUE}: ${e.message}`);
              }
            }

            async function fetchIssue(number) {
              const { data } = await github.rest.issues.get({ owner, repo, issue_number: Number(number) });
              return data;
            }

            async function findOpenDraftPRsReferencing(issueNumber) {
              const q = `repo:${owner}/${repo} type:pr is:open ${issueNumber}`;
              const res = await github.rest.search.issuesAndPullRequests({ q, per_page: 10 });
              const items = res.data.items || [];
              const prs = [];
              for (const it of items) {
                if (!('pull_request' in it)) continue;
                const prNum = it.number;
                const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNum });
                if (pr.state === 'open') {
                  prs.push({ number: pr.number, title: pr.title, head: pr.head.ref, draft: pr.draft, html_url: pr.html_url, updated_at: pr.updated_at });
                }
              }
              // prefer one PR; if multiple, keep the most recently updated
              prs.sort((a,b) => new Date(b.updated_at) - new Date(a.updated_at));
              return prs;
            }

            function fmtDate(iso) {
              if (!iso) return '';
              const d = new Date(iso);
              return d.toISOString().replace('T',' ').replace('Z',' UTC');
            }

            await ensureStartOnPolicyIssue();

            const lines = [];
            lines.push(HEADER);
            lines.push('Sprint 0 — Daily Summary (auto)');
            lines.push('');
            lines.push('Scope');
            lines.push('- #915 / #917 / #918 / #916');
            lines.push('- Child: #' + CHILD_ISSUES.join(' / #'));
            lines.push('');
            lines.push('Status');

            for (const id of CHILD_ISSUES) {
              try {
                const issue = await fetchIssue(id);
                const prs = await findOpenDraftPRsReferencing(id);
                const prLine = prs.length
                  ? `PR #${prs[0].number} (${prs[0].draft ? 'Draft' : 'Open'}) · ${prs[0].head} · ${fmtDate(prs[0].updated_at)} · ${prs[0].html_url}`
                  : 'No open PR linked';
                const labels = (issue.labels || []).map(l => typeof l === 'string' ? l : l.name).join(', ');
                lines.push(`- #${id}: ${issue.title} · ${issue.state} · ${labels} · ${fmtDate(issue.updated_at)}\n  - ${prLine}`);
              } catch (e) {
                lines.push(`- #${id}: fetch error: ${e.message}`);
              }
            }

            lines.push('');
            lines.push('Priorities');
            lines.push('- Verify Lite baseline (#958) and actionlint/printf (#959) first.');
            lines.push('- CI/Security policy (#963), then slash-command mappings (#962).');
            lines.push('');
            lines.push('Risks/Blockers');
            lines.push('- None marked by automation. Post /block on impacted issue if CI repeatedly fails or permissions block.');
            lines.push('');
            lines.push('Next Actions');
            lines.push('- Keep one Draft PR per child issue. Flip to ready-for-review after green on Verify Lite.');

            const body = lines.join('\n');

            // Upsert comment on ROOT_ISSUE using HEADER marker
            const comments = await github.paginate(github.rest.issues.listComments, { owner, repo, issue_number: Number(ROOT_ISSUE), per_page: 100 });
            const mine = comments.find(c => (c.body || '').startsWith(HEADER));
            if (mine) {
              await github.rest.issues.updateComment({ owner, repo, comment_id: mine.id, body });
            } else {
              await github.rest.issues.createComment({ owner, repo, issue_number: Number(ROOT_ISSUE), body });
            }

            core.notice('Daily summary upserted.');
