import { existsSync, mkdirSync, readFileSync, writeFileSync } from 'fs';
import path from 'path';
import { safeExit } from '../../utils/safe-exit.js';

export type TestsScaffoldOptions = {
  input: string;
  out?: string;
  specId?: string;
  property?: boolean;
  overwrite?: boolean;
};

type FileEntry = {
  relativePath: string;
  content: string;
};

export function extractAcceptanceCriteria(markdown: string): string[] {
  const lines = markdown.split(/\r?\n/);
  const start = lines.findIndex((line) =>
    /^#{2,6}\s+.*(Acceptance Criteria|Acceptance|受入基準)/i.test(line.trim()),
  );

  const candidates: string[] = [];

  const pushBullet = (line: string) => {
    const match = line.match(
      /^\s*[-*]\s*(?:\[[ xX]\]\s*)?(?:AC[-_ ]?\d+\s*(?:\([^)]*\))?:\s*)?(.+?)\s*$/,
    );
    if (match?.[1]) {
      candidates.push(match[1].trim());
    }
  };

  const captureSectionCriteria = () => {
    if (start < 0) {
      return;
    }
    for (let i = start + 1; i < lines.length; i += 1) {
      const line = lines[i] ?? '';
      const trimmed = line.trim();
      if (/^#{1,6}\s+/.test(trimmed)) {
        break;
      }

      const bullet = line.match(
        /^\s*[-*]\s*(?:\[[ xX]\]\s*)?(?:AC[-_ ]?\d+\s*(?:\([^)]*\))?:\s*)?(.*)\s*$/,
      );
      if (!bullet) {
        continue;
      }

      let body = (bullet[1] ?? '').trim().replace(/[:：]\s*$/, '');
      const gwtParts: string[] = [];
      let j = i + 1;
      for (; j < lines.length; j += 1) {
        const nextLine = lines[j] ?? '';
        const nextTrimmed = nextLine.trim();
        if (/^#{1,6}\s+/.test(nextTrimmed)) {
          break;
        }
        if (/^\s*[-*]\s+/.test(nextLine)) {
          break;
        }
        const gwt = nextTrimmed.match(/^(Given|When|Then)\b.*$/i);
        if (gwt?.[0]) {
          gwtParts.push(gwt[0].trim());
        } else if (!body && nextTrimmed.length > 0) {
          body = nextTrimmed;
        }
      }
      const criterion = [body, ...gwtParts].filter(Boolean).join(' ').trim();
      if (criterion.length > 0) {
        candidates.push(criterion);
      }
      i = j - 1;
    }
  };

  captureSectionCriteria();
  if (candidates.length > 0) {
    return normalizeCriteria(candidates);
  }

  if (start >= 0) {
    for (let i = start + 1; i < lines.length; i += 1) {
      const line = lines[i] ?? '';
      if (/^#{1,6}\s+/.test(line.trim())) {
        break;
      }
      pushBullet(line);
    }
  }

  if (candidates.length > 0) {
    return normalizeCriteria(candidates);
  }

  for (const line of lines) {
    const acBullet = line.match(
      /^\s*[-*]\s*(?:\[[ xX]\]\s*)?AC[-_ ]?\d+\s*(?:\([^)]*\))?:\s*(.+?)\s*$/,
    );
    if (acBullet?.[1]) {
      candidates.push(acBullet[1].trim());
    }
  }

  if (candidates.length > 0) {
    return normalizeCriteria(candidates);
  }

  for (const line of lines) {
    pushBullet(line);
  }
  return normalizeCriteria(candidates);
}

function normalizeCriteria(criteria: string[]): string[] {
  return criteria
    .map((item) => item.replace(/\s+/g, ' ').trim())
    .filter((item) => item.length > 0);
}

function deriveSpecId(inputPath: string, override?: string): string {
  const raw = (override || path.basename(inputPath, path.extname(inputPath))).trim();
  return (
    raw
      .toLowerCase()
      .replace(/[^a-z0-9._-]+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '') || 'spec'
  );
}

function splitGivenWhenThen(text: string): { given: string; when: string; then: string } | null {
  const normalized = text.replace(/\s+/g, ' ').trim();
  const match = normalized.match(/(Given .*?)(?:\s+)(When .*?)(?:\s+)(Then .*)/i);
  if (!match) {
    return null;
  }
  const given = match[1];
  const when = match[2];
  const then = match[3];
  if (!given || !when || !then) {
    return null;
  }
  return { given: given.trim(), when: when.trim(), then: then.trim() };
}

function buildFeatureContent(specId: string, criteria: string[]): string {
  const lines: string[] = [];
  lines.push(`Feature: ${specId}`);
  lines.push('  # Generated by ae tests:scaffold');
  lines.push('');

  criteria.forEach((criterion, index) => {
    const scenarioName = `AC-${index + 1}: ${criterion}`;
    const gwt = splitGivenWhenThen(criterion);
    lines.push(`  Scenario: ${scenarioName}`);
    if (gwt) {
      lines.push(`    ${gwt.given}`);
      lines.push(`    ${gwt.when}`);
      lines.push(`    ${gwt.then}`);
    } else {
      lines.push('    Given TODO: setup precondition');
      lines.push('    When TODO: execute behavior');
      lines.push(`    Then ${criterion}`);
    }
    lines.push('');
  });

  return `${lines.join('\n').trimEnd()}\n`;
}

function buildAcceptanceMapContent(specId: string, criteria: string[]): string {
  const lines: string[] = [];
  lines.push(`# Acceptance Map: ${specId}`);
  lines.push('');
  lines.push('| AC | Criterion | Test Artifact | Status |');
  lines.push('| --- | --- | --- | --- |');
  criteria.forEach((criterion, index) => {
    lines.push(`| AC-${index + 1} | ${criterion} | \`bdd/${specId}.feature\` | TODO |`);
  });
  lines.push('');
  lines.push('## Notes');
  lines.push('- Fill Test Artifact with actual test file paths after implementation.');
  return `${lines.join('\n').trimEnd()}\n`;
}

function buildPropertyTestContent(specId: string): string {
  return `import { describe, it, expect } from 'vitest';\n` +
    `import fc from 'fast-check';\n\n` +
    `describe('property:${specId}', () => {\n` +
    `  it('maintains invariant for generated inputs', () => {\n` +
    `    fc.assert(\n` +
    `      fc.property(fc.anything(), (input) => {\n` +
    `        expect(input).toBeDefined();\n` +
    `      }),\n` +
    `    );\n` +
    `  });\n` +
    `});\n`;
}

function ensureWritable(filePath: string, overwrite: boolean) {
  if (!overwrite && existsSync(filePath)) {
    throw new Error(`Output file already exists: ${filePath} (use --overwrite to replace)`);
  }
}

export function createScaffoldFiles(
  markdown: string,
  specId: string,
  includeProperty = true,
): FileEntry[] {
  const criteria = extractAcceptanceCriteria(markdown);
  if (criteria.length === 0) {
    throw new Error('No acceptance criteria bullets found in input document');
  }

  const files: FileEntry[] = [
    {
      relativePath: path.join('bdd', `${specId}.feature`),
      content: buildFeatureContent(specId, criteria),
    },
    {
      relativePath: `${specId}.acceptance.md`,
      content: buildAcceptanceMapContent(specId, criteria),
    },
  ];

  if (includeProperty) {
    files.push({
      relativePath: path.join('property', `${specId}.property.test.ts`),
      content: buildPropertyTestContent(specId),
    });
  }

  return files;
}

export function testsScaffold(options: TestsScaffoldOptions) {
  if (!options.input) {
    throw new Error('Missing required option: --input <file>');
  }

  const inputPath = path.resolve(options.input);
  const markdown = readFileSync(inputPath, 'utf8');
  const specId = deriveSpecId(inputPath, options.specId);
  const outputDir = path.resolve(options.out || path.join('tests', 'generated', 'spec-kit', specId));
  const includeProperty = options.property !== false;
  const overwrite = options.overwrite === true;

  const files = createScaffoldFiles(markdown, specId, includeProperty);
  mkdirSync(outputDir, { recursive: true });

  for (const file of files) {
    const targetPath = path.join(outputDir, file.relativePath);
    mkdirSync(path.dirname(targetPath), { recursive: true });
    ensureWritable(targetPath, overwrite);
    writeFileSync(targetPath, file.content, 'utf8');
  }

  console.log(`✅ Generated ${files.length} scaffold file(s) in ${outputDir}`);
  for (const file of files) {
    console.log(` - ${file.relativePath}`);
  }
}

export function handleTestsScaffold(options: TestsScaffoldOptions) {
  try {
    testsScaffold(options);
  } catch (error: unknown) {
    const message = error instanceof Error ? error.message : 'Unknown error';
    console.error(`❌ ${message}`);
    safeExit(1);
  }
}
