import type { FormalPlan, FormalPlanAction, FormalPlanFormula } from './types.js';

export const DEFAULT_EXTENDS = ['Naturals', 'Sequences'];

export type TlaRenderOptions = {
  moduleName?: string;
  extends?: string[];
  includeSpec?: boolean;
};

const INDENT = '  ';

function formatNameList(names: string[]) {
  return names.join(', ');
}

function formatTuple(names: string[]) {
  return `<<${formatNameList(names)}>>`;
}

function formatActionBlock(actions: FormalPlanAction[]) {
  if (actions.length === 0) {
    return [];
  }
  return actions.map((action) => `${action.name} == ${action.tla}`);
}

function formatFormulaBlock(label: string, formulas?: FormalPlanFormula[]) {
  if (!formulas || formulas.length === 0) {
    return [];
  }
  const lines = [label];
  for (const formula of formulas) {
    lines.push(`${formula.name} == ${formula.tla}`);
  }
  return lines;
}

export function renderTlaModule(
  plan: FormalPlan,
  { moduleName = 'Spec', extends: extendsList, includeSpec = true }: TlaRenderOptions = {},
) {
  const constants = plan.constants?.map((entry) => entry.name) ?? [];
  const variables = plan.variables.map((entry) => entry.name);
  const initAction = plan.actions.find((action) => action.name === 'Init');
  const nextActions = plan.actions.filter((action) => action.name !== 'Init');
  const activeExtends = (extendsList ?? DEFAULT_EXTENDS).filter(Boolean);
  const lines: string[] = [];

  lines.push(`------------------------------ MODULE ${moduleName} ------------------------------`);
  if (activeExtends.length > 0) {
    lines.push(`EXTENDS ${formatNameList(activeExtends)}`);
  }
  lines.push('');
  lines.push('(* Generated by formalize-coder from formal.yaml. *)');
  lines.push('');

  if (constants.length > 0) {
    lines.push('CONSTANTS');
    lines.push(`${INDENT}${formatNameList(constants)}`);
    lines.push('');
  }

  lines.push('VARIABLES');
  lines.push(`${INDENT}${formatNameList(variables)}`);
  lines.push('');
  lines.push(`vars == ${formatTuple(variables)}`);
  lines.push('');

  if (initAction) {
    lines.push(`Init == ${initAction.tla}`);
  } else {
    lines.push('Init == TRUE');
  }
  lines.push('');

  const actionDefinitions = formatActionBlock(
    initAction ? plan.actions.filter((action) => action.name !== 'Init') : plan.actions,
  );
  if (actionDefinitions.length > 0) {
    lines.push(...actionDefinitions);
    lines.push('');
  }

  if (nextActions.length > 0) {
    lines.push('Next ==');
    nextActions.forEach((action) => {
      lines.push(`${INDENT}\\/ ${action.name}`);
    });
  } else {
    lines.push('Next == UNCHANGED vars');
  }

  if (includeSpec) {
    lines.push('');
    lines.push('Spec == Init /\\ [][Next]_vars');
  }

  const invariantLines = formatFormulaBlock('\\* Invariants', plan.invariants);
  if (invariantLines.length > 0) {
    lines.push('');
    lines.push(...invariantLines);
  }

  const livenessLines = formatFormulaBlock('\\* Liveness', plan.liveness);
  if (livenessLines.length > 0) {
    lines.push('');
    lines.push(...livenessLines);
  }

  const assumptionLines = formatFormulaBlock('\\* Assumptions', plan.assumptions);
  if (assumptionLines.length > 0) {
    lines.push('');
    lines.push(...assumptionLines);
  }

  lines.push('');
  lines.push('=============================================================================');

  return lines.join('\n');
}
